<html><head><!--Google Tag Manager--><script class="gtm">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-W59SWTR');</script><!--End Google Tag Manager--></head><body><!--Google Tag Manager (noscript)--><noscript class="gtm"><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-W59SWTR" style="display:none;visibility:hidden" width="0"></iframe></noscript><!--End Google Tag Manager (noscript)--><b>Affine Transformation - Theory</b><p></p>

<p>An affine transformation is a geometrical transformation which moves points
  in space such that points which were lying on a line remain so after the
  transformation. </p>

<p>Given a point which is a point location [x, y]<sup>T</sup> , transformed
  location after translation, rotation and scaling can be as follows.</p>
 
<p align="center" style="text-align:center"><img height="47" id="Picture 1" src="affine/images/image012.jpg" width="130"/></p>

<table border="1" cellpadding="0" cellspacing="0" style="border-collapse:collapse;border:none; color: black;">
  <tbody><tr style="height:54.85pt">
    <td style="width:1.45in;border:solid black 1.0pt;
	padding:0in 5.4pt 0in 5.4pt;height:54.85pt" valign="top" width="139">
      Translation
    </td>
    <td style="width:157.5pt;border:solid black
	1.0pt;
	border-left:none;padding:0in 5.4pt 0in 5.4pt;height:54.85pt" valign="top" width="210">
      <img height="45" src="affine/images/image013.jpg" width="60"/>
	<img height="49" src="affine/images/image014.jpg" width="56"/><p></p>
    </td>
    <td style="width:132.3pt;border:solid black
	1.0pt;
	border-left:none;padding:0in 5.4pt 0in 5.4pt;height:54.85pt" valign="top" width="176">
      <img height="48" src="affine/images/image015.jpg" width="76"/><p></p>
    </td>
  </tr>
  <tr>
    <td style="width:1.45in;border:solid black 1.0pt;
	border-top:none;padding:0in 5.4pt 0in 5.4pt" valign="top" width="139">

      Rotation (Î¸)

    </td>
    <td style="width:157.5pt;border-top:none;border-left:
	none;border-bottom:solid black 1.0pt;border-right:solid black
	1.0pt;
	padding:0in 5.4pt 0in 5.4pt" valign="top" width="210">
      <img height="43" src="affine/images/image016.jpg" width="131"/>
	<img height="48" src="affine/images/image017.jpg" width="50"/><p></p>
    </td>
    <td style="width:132.3pt;border-top:none;border-left:
	none;border-bottom:solid black 1.0pt;border-right:solid
	black 1.0pt;
	padding:0in 5.4pt 0in 5.4pt" valign="top" width="176">
      <img height="18" id="Picture 7" src="affine/images/image018.jpg" width="133"/><p></p>
      <img height="18" id="Picture 8" src="affine/images/image019.jpg" width="133"/><p></p>
    </td>
  </tr>
  <tr>
    <td style="width:1.45in;border:solid black
        1.0pt;
	border-top:none;padding:0in 5.4pt 0in 5.4pt" valign="top" width="139">
      Scaling
    </td>
    <td style="width:157.5pt;border-top:none;border-left:
	none;border-bottom:solid black 1.0pt;border-right:solid black
	1.0pt;
	padding:0in 5.4pt 0in 5.4pt" valign="top" width="210">
      <img height="50" src="affine/images/image020.jpg" width="70"/>
	<img height="47" src="affine/images/image021.jpg" width="49"/><p></p>
    </td>
    <td style="width:132.3pt;border-top:none;border-left:
	none;border-bottom:solid black 1.0pt;border-right:solid
	black 1.0pt;
	padding:0in 5.4pt 0in 5.4pt" valign="top" width="176">
      <img height="19" id="Picture 11" src="affine/images/image022.jpg" width="80"/><p></p>
      <img height="22" id="Picture 12" src="affine/images/image023.jpg" width="77"/><p></p>
        </td>
     </tr>
  </tbody></table>

<p> To geometrically transform an image, the result we seek is an image with
  transformed coordinates. The result of applying the transformation function
  is generally not an integer particularly in case of rotation and
  scaling. This poses a problem since the image is defined on a grid
  (coordnates have to be integer valued). The solution is interpolation.</p><p>n
  implementation, image rotation is done as follows. Given I[m,n] to find a
  transformed image X[m., n.] where [m., n.]= A x [m, n] + B according to the
  above given equation: </p>

<ol start="1" type="1"><li>Create a dummy array X[m., n.]. </li>
  <li>Find the locations [m, n] in I that correspond to locations [., n.] in
  the image X by applying the inverse transformation. I.e. A<sup>-1</sup>
  ([m., n.]-B) = [m, n]. This can result in non-integer locations.</li>
  <li>Find the pixel value at these source locations. If it is non-integer
  valued locations, use an interpolation function.</li>
  </ol><p>Example: Consider A to be rotation by 30 degrees. Let us take the
  location [12, 13] in X and find its corresponding location in I. This will
  be [3.89 17.26]. To determine the value of I at this location, we can use
  the known values closest to this location</p>

  <p align="center" style="text-align:center"><img height="150" id="Picture 1" src="affine/images/image024.jpg" width="500"/></p>

  <p align="center" style="text-align:center"><img height="70" id="Picture 1" src="affine/images/image025.jpg" width="250"/></p>
  

<p><b>Option 1:</b> Round off the [m, n] and take the pixel value at that
  location. This is known as the nearest neighbour interpolation method.</p>

<p><b>Option 2:</b> Take the weighted average of the 4 neighbouring
  pixels. The weights are the distance between the desired location and that
  of the neighbours. The common form is the bilinear form which is a second
  order approximation and equivalent to fitting a straight line pairs of
  neighbouring pixels.</p>

<p><b>Option 3:</b> Take a nonlinear combination of the 16 neighbouring
  pixels. The standard is to use a third order approximation and fit two
  piecewise cubic polynomials on to the neighbouring pixels. Hence the
  interpolation function is called the bicubic interpolation method.</p>
</body></html>